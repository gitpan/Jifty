=head1 NAME

Jifty::Manual::Cookbook

=head1 DESCRIPTION

This document aims to provide solutions to common questions of "How do
I do I<x> with Jifty?" While the solutions here certainly aren't the
only way to do things, they're generally the solutions the developers
of Jifty use, and ones that work pretty well.

=head1 HOW DO I ...

=head2 Add Atom/RSS Feeds ?

You could generate atom/rss feeds for virtually any model in your application.
For instance, suppose there's a "Post" model (like a blog post), you could use
L<XML::Feed> to do this:

    # In '/feed' template
    <%args>
    $type
    </%args>
    <%init>
    use XML::Feed;
    my $posts = MyApp::Model::PostCollection->new();
    $posts->unlimit();
    
    my $feed = XML::Feed->new( $type );
    $feed->title( Jifty->config->framework('ApplicationName') . " Feed" );
    $feed->link( Jifty->web->url );
    $feed->description( $feed->title );
    
    while( my $post = $posts->next ) {
        my $feed_entry = XML::Feed::Entry->new($type);
        $feed_entry->title($post->title);
        $feed_entry->author($post->author->username);
        $feed_entry->link( Jifty->web->url . "/posts/" . $post->id );
        $feed_entry->issued( $post->created_on );
        $feed_entry->summary( $post->body );
        $feed->add_entry($feed_entry);
    }
    </%init>
    <% $feed->as_xml |n%>

And add this in C<MyApp/Dispatcher.pm> to make URI look prettier:

    on qr{^/feed/(atom|rss|rss2)}, run {
        set type => $1;
        show('/feed');
    };
    
And of course, you need to put these in your HTML header tempalte
(conventionally that's C</_elements/header>):

    <link rel="alternate" type="application/atom+xml" title="Atom" href="/feed/atom" />
    <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed/rss" />

=head2 Emulate 'created_on' field like Rails ?

In Rails, if you have a field named 'created_on', it's automatically
set to the creation time of the record. How can I emulate this
behaviour in Jifty ?

The trick here is to use L<Scalar::Defer>. And declare your column
like this:

    column created_on =>
        type is 'timestamp',
        label is 'Created On',
        default is defer { DateTime->now },
        filters are 'Jifty::DBI::Filter::DateTime';

This approach is not really accurate, if you render this field in a
form, then the defer value is evaluated by the time of rendering,
which might be way eariler then the creation of record. However, it is
the easiest one. For more accurate approch, override model's
C<before_create()> method:

    sub before_create {
        my ($self, $attr) = @_;
        $attr->{'created_on'} = DateTime->now;
    };

=head2 Limit access to pages to logged-in users

The best place to do this is probably in your application's
L<Dispatcher|Jifty::Dispatcher>. If, for example, you wanted to limit
access to C</secret> to logged-in users, you could write:

    before qr'^/secret' => run {
        unless(Jifty->web->current_user->id) {
            Jifty->web->tangent('/login');
        }
    };

Then, in your login form component, you would write something like:

    <% Jifty->web->return(to => '/', submit => $login_action) $>

The combination of the C<tangent> and C<return> will cause the user to
be returned to wherever they came from. See L<Jifty::Continuation> for
more information.

If you want model-level access control, Jifty provides a ready-built
ACL system for its models; See L<Jifty::Manual::AccessControl> for
details.

Finally, you can also allow or deny specific actions in the
dispatcher, to limit who is able to perform what actions -- see
L<Jifty::API>.

=head2 Run my Jifty app as fascgi in Apache/Lighttpd ?

Jifty provides a really simple way to run the application as a fastcgi
server. The complete instruction and example is in C<'jifty help
fastcgi'> for both Apache server and Lighttpd server. (Please cd to
your app dir before run this command.)

You'll have to install C<CGI::Fast> and C<FCGI> module for this.

=head2 Take actions based on data in URLs

You can add actions to the request based on data in URLs, or anything
else, using
L<Jifty::Request::add_action|Jifty::Request/add_action>. For example,
suppose you wanted to make the path C</logout> log the user out, and
redirect them to the home page. You could write:

    before '/logout' => {
        Jifty->web->request->add_action( class => 'Logout' );
        Jifty->web->request->add_action(class     => 'Redirect',
                                        arguments => { url => '/' });
    };

=head2 Pass HTML form input directly to components

Sometimes, you don't want to take an action based on input from HTML
forms, but just want to change how the page is displayed, or do
something similarly transient.

C<Jifty::Action> is great, but it doesn't have to be the answer to
everything. For cases like this, it's fine to use typical HTML C<<
<input>s >>. Their values will be accessible as request arguments, so
you can fetch them with C<get> in the dispatcher, and they will be
passed as arguments to top-level Mason components that list them in
C<< <%args> >>. And don't worry about namespace conflicts with Jifty's
auto-generated argument fields -- Jifty prefixes all its C<name>s with
C<J:> so there won't be a problem.

=head2 Perform database migration

Edit etc/config.yaml and change Database->Version to a proper value
(say, 0.0.2). Then run

    jifty schema --setup

Jifty would inspect current database and perform proper actions.
You could give a C<--print> option to see the actual SQL statement:

    jifty schema --setup --print


=head2 Use different table names than the ones Jifty automatically creates

In YourApp::Record define a _guess_table_name sub that doesn't
pluralises or pluralises differently.

